<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no">
<meta name="author" content="文心鱼塘">



<meta name="description" content="设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。">
<meta name="keywords" content="admin123456">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈设计模式">
<meta property="og:url" content="https://znw957799185.github.io/2019/08/06/浅谈设计模式/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-08-06T07:44:19.824Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈设计模式">
<meta name="twitter:description" content="设计模式是一套被反复使用、多数人知晓的、经过分类的、代码设计经验的总结。 使用设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性。设计模式使代码编写真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。">

<link rel="apple-touch-icon" href="/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.png">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>浅谈设计模式 | Hexo</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: true
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head></html>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/avatar.jpg" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">文心鱼塘</a></h1>
        </hgroup>

        

        
            <form id="search-form">
            <input type="text" id="local-search-input" name="q" placeholder="search..." class="search form-control" autocomplete="off" autocorrect="off" searchonload="false" />
            <i class="fa fa-times" onclick="resetSearch()"></i>
            </form>
            <div id="local-search-result"></div>
            <p class='no-result'>No results found <i class='fa fa-spinner fa-pulse'></i></p>
        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">所有文章</a></li>
                        
                            <li><a href="/tags/">标签云</a></li>
                        
                            <li><a href="/about/">关于我</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" href="mailto:957799185@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" href="https://github.com/znw957799185" title="GitHub"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://pages.github.com/">GitHub</a>
                    
                      <a class="main-nav-link switch-friends-link" href="https://znw957799185.github.io/">heartfish</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">专注于前端</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">文心鱼塘</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/avatar.jpg" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">文心鱼塘</a></h1>
            </hgroup>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">所有文章</a></li>
                
                    <li><a href="/tags/">标签云</a></li>
                
                    <li><a href="/about/">关于我</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa Email" target="_blank" href="mailto:957799185@qq.com" title="Email"></a>
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/znw957799185" title="GitHub"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-浅谈设计模式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/06/浅谈设计模式/" class="article-date">
      <time datetime="2019-08-06T06:18:45.000Z" itemprop="datePublished">2019-08-06</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      浅谈设计模式
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        

        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <h2 id="GoF的23种设计模式的功能"><a href="#GoF的23种设计模式的功能" class="headerlink" title="GoF的23种设计模式的功能"></a>GoF的23种设计模式的功能</h2><p> 必须指出，这 23 种设计模式不是孤立存在的，很多模式之间存在一定的关联关系，在大的系统开发中常常同时使用多种设计模式。</p>
<p>设计模式有两种分类方法，即根据模式的目的来分和根据模式的作用的范围来分.</p>
<h2 id="根据目的来分"><a href="#根据目的来分" class="headerlink" title="根据目的来分"></a>根据目的来分</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>用于描述“怎样创建对象”，它的主要特点是“将对象的创建与使用分离”。<br>GoF 中提供了单例、原型、工厂方法、抽象工厂、建造者等 5 种创建型模式。</p>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>用于描述如何将类或对象按某种布局组成更大的结构，<br>GoF 中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>用于描述类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，以及怎样分配职责。<br>GoF 中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p>
<h2 id="根据作用范围来分"><a href="#根据作用范围来分" class="headerlink" title="根据作用范围来分"></a>根据作用范围来分</h2><h3 id="类模式"><a href="#类模式" class="headerlink" title="类模式"></a>类模式</h3><p>用于处理类与子类之间的关系，这些关系通过继承来建立，是静态的，在编译时刻便确定下来了。GoF中的工厂方法、适配器、模板方法、解释器属于该模式。</p>
<h3 id="对象模式"><a href="#对象模式" class="headerlink" title="对象模式"></a>对象模式</h3><p>用于处理对象之间的关系，这些关系可以通过组合或聚合来实现，在运行时刻是可以变化的，更具动态性。GoF 中除了以上 4 种，其他的都是对象模式</p>
<h2 id="以下是按定义描述23种设计模式"><a href="#以下是按定义描述23种设计模式" class="headerlink" title="以下是按定义描述23种设计模式"></a>以下是按定义描述23种设计模式</h2><p>单例（Singleton）模式 : 某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。<br>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。<br>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。<br>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。<br>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。<br>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。<br>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。<br>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。<br>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。<br>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。<br>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。<br>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。<br>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。<br>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。<br>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。<br>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。<br>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。<br>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。<br>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。<br>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。<br>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。<br>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。<br>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</p>
<h1 id="软件设计遵循原则"><a href="#软件设计遵循原则" class="headerlink" title="软件设计遵循原则"></a>软件设计遵循原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p>
<h2 id="开闭原则："><a href="#开闭原则：" class="headerlink" title="开闭原则："></a>开闭原则：</h2><p>软件实体应当对扩展开放，对修改关闭，这就是开闭原则的经典定义。<br>开闭原则的含义是：当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p>
<p> 开闭原则的作用<br>1.软件遵守开闭原则的话——软件测试时只需要对扩展的代码进行测试就可以了，因为原有的测试代码仍然能够正常运行。<br>2.可以提高代码的可复用性——粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。<br>3.可以提高软件的可维护性——遵守开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p>
<h2 id="里氏替换原则："><a href="#里氏替换原则：" class="headerlink" title="里氏替换原则："></a>里氏替换原则：</h2><p>继承必须确保超类所拥有的性质在子类中仍然成立。<br>里氏替换原则主要阐述了有关继承的一些原则，也就是什么时候应该使用继承，什么时候不应该使用继承，以及其中蕴含的原理。里氏替换原是继承复用的基础，它反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p>
<p>里氏替换原则的作用：<br>里氏替换原则是实现开闭原则的重要方式之一。<br>它克服了继承中重写父类造成的可复用性变差的缺点。<br>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</p>
<h2 id="依赖倒置原则："><a href="#依赖倒置原则：" class="headerlink" title="依赖倒置原则："></a>依赖倒置原则：</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。</p>
<p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。</p>
<p>由于在软件设计中，细节具有多变性，而抽象层则相对稳定，因此以抽象为基础搭建起来的架构要比以细节为基础搭建起来的架构要稳定得多。这里的抽象指的是接口或者抽象类，而细节是指具体的实现类。</p>
<p>使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p>
<p>依赖倒置原则的主要作用：<br>依赖倒置原则可以降低类间的耦合性。<br>依赖倒置原则可以提高系统的稳定性。<br>依赖倒置原则可以减少并行开发引起的风险。<br>依赖倒置原则可以提高代码的可读性和可维护性。</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则:"></a>单一职责原则:</h2><p>这里的职责是指类变化的原因，单一职责原则规定一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分<br>该原则提出对象不应该承担太多职责，如果一个对象承担了太多的职责，至少存在以下两个缺点：<br>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力；<br>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费</p>
<p>单一职责原则的优点：<br>单一职责原则的核心就是控制类的粒度大小、将对象解耦、提高其内聚性。如果遵循单一职责原则将有以下优点。<br>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。<br>提高类的可读性。复杂性降低，自然其可读性会提高。<br>提高系统的可维护性。可读性提高，那自然更容易维护了。<br>变更引起的风险降低。变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则:"></a>接口隔离原则:</h2><p>定义1是：要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。<br>定义2是：客户端不应该被迫依赖于它不使用的方法。<br>定义3是：一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>以上定义的含义是：要为各个类建立它们需要的专用接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。<br>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，两者不同点：<br>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。<br>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p>
<p>接口隔离原则的优点<br>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点。<br>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。<br>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。<br>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。<br>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。<br>能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</p>
<h2 id="迪米特法则："><a href="#迪米特法则：" class="headerlink" title="迪米特法则："></a>迪米特法则：</h2><p>如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<p>迪米特法则的优点：<br>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。<br>降低了类之间的耦合度，提高了模块的相对独立性。<br>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</p>
<p>但是，过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p>
<h2 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则:"></a>合成复用原则:</h2><p>它要求在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。</p>
<p>如果要使用继承关系，则必须严格遵循里氏替换原则。合成复用原则同里氏替换原则相辅相成的，两者都是开闭原则的具体实现规范。</p>
<p>合成复用原则的重要性<br>通常类的复用分为继承复用和合成复用两种，继承复用虽然有简单和易实现的优点，但它也存在以下缺点。<br>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。<br>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。<br>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。<br>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点。<br>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。<br>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。<br>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</p>
<h2 id="创建型模式-1"><a href="#创建型模式-1" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。<br>就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p>
<p>创建型模式分为以下几种。<br>1、单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。<br>2、原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。<br>3、工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。<br>4、抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。<br>5、建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</p>
<h3 id="1、单例（Singleton）模式"><a href="#1、单例（Singleton）模式" class="headerlink" title="1、单例（Singleton）模式"></a>1、单例（Singleton）模式</h3><p>单例（Singleton）模式：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。例如，Windows 中只能打开一个任务管理器，这样可以避免因打开多个任务管理器窗口而造成内存资源的浪费，或出现各个窗口显示内容的不一致等错误。</p>
<p>在计算机系统中，还有 Windows 的回收站、操作系统中的文件系统、多线程中的线程池、显卡的驱动程序对象、打印机的后台处理服务、应用程序的日志对象、数据库的连接池、网站的计数器、应用程序中的对话框、系统中的缓存等常常被设计成单例。</p>
<p>单例模式有 3 个特点：<br>单例类只有一个实例对象；<br>该单例对象必须由单例类自行创建；<br>单例类对外提供一个访问该单例的全局访问点；</p>
<h3 id="2、原型（Prototype）模式"><a href="#2、原型（Prototype）模式" class="headerlink" title="2、原型（Prototype）模式"></a>2、原型（Prototype）模式</h3><p>原型（Prototype）模式：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。</p>
<p>例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</p>
<p>原型模式的主要优点：<br>在有些系统中，存在大量相同或相似对象的创建问题，如果用传统的构造函数来创建对象，会比较复杂且耗时耗资源，用原型模式生成对象就很高效，就像孙悟空拔下猴毛轻轻一吹就变出很多孙悟空一样简单。</p>
<h3 id="3、工厂方法（FactoryMethod"><a href="#3、工厂方法（FactoryMethod" class="headerlink" title="3、工厂方法（FactoryMethod)"></a>3、工厂方法（FactoryMethod)</h3><p>工厂方法（FactoryMethod）：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。<br>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。<br>本节介绍的“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<p>在现实生活中社会分工越来越细，越来越专业化。各种产品有专门的工厂生产，彻底告别了自给自足的小农经济时代，这大大缩短了产品的生产周期，提高了生产效率。<br>同样，在软件开发中能否做到软件对象的生产和使用相分离呢？能否在满足“开闭原则”的前提下，客户随意增删或改变对软件相关对象的使用呢？这就是本节要讨论的问题。</p>
<p>工厂方法模式主要优点：<br>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；<br>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</p>
<p>工厂方法模式主要缺点：<br>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</p>
<h3 id="4、抽象工厂（AbstractFactory）"><a href="#4、抽象工厂（AbstractFactory）" class="headerlink" title="4、抽象工厂（AbstractFactory）"></a>4、抽象工厂（AbstractFactory）</h3><p>抽象工厂（AbstractFactory）：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>使用抽象工厂模式一般要满足以下条件。<br>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。<br>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</p>
<p>抽象工厂模式主要优点：<br>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。<br>当增加一个新的产品族时不需要修改原代码，满足开闭原则。</p>
<p>抽象工厂模式主要缺点：<br>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<h3 id="5、建造者（Builder）模式"><a href="#5、建造者（Builder）模式" class="headerlink" title="5、建造者（Builder）模式"></a>5、建造者（Builder）模式</h3><p>建造者（Builder）模式：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。<br>它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。<br>在软件开发过程中有时需要创建一个复杂的对象，这个复杂对象通常由多个子部件按一定的步骤组合而成。<br>例如，计算机是由 OPU、主板、内存、硬盘、显卡、机箱、显示器、键盘、鼠标等部件组装而成的，采购员不可能自己去组装计算机，而是将计算机的配置要求告诉计算机销售公司，计算机销售公司安排技术人员去组装计算机，然后再交给要买计算机的采购员。</p>
<p>生活中这样的例子很多，如游戏中的不同角色，其性别、个性、能力、脸型、体型、服装、发型等特性都有所差异；还有汽车中的方向盘、发动机、车架、轮胎等部件也多种多样；每封电子邮件的发件人、收件人、主题、内容、附件等内容也各不相同。</p>
<p>以上所有这些产品都是由多个部件构成的，各个部件可以灵活选择，但其创建步骤都大同小异。这类产品的创建无法用前面介绍的工厂模式描述，只有建造者模式可以很好地描述该类产品的创建。<br>建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</p>
<p>建造者模式主要优点：<br>各个具体的建造者相互独立，有利于系统的扩展。<br>客户端不必知道产品内部组成的细节，便于控制细节风险。</p>
<p>建造者模式主要缺点：<br>产品的组成部分必须相同，这限制了其使用范围。<br>如果产品的内部变化复杂，该模式会增加很多的建造者类。</p>
<h2 id="结构型模式-1"><a href="#结构型模式-1" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。<br>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：<br>06、代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。<br>07、适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。<br>08、桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。<br>09、装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。<br>10、外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。<br>11、享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。<br>12、组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p>
<h3 id="06、代理（Proxy）模式"><a href="#06、代理（Proxy）模式" class="headerlink" title="06、代理（Proxy）模式"></a>06、代理（Proxy）模式</h3><p>代理（Proxy）模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。<br>例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。<br>在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。</p>
<p>代理模式主要优点：<br>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；<br>代理对象可以扩展目标对象的功能；<br>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</p>
<p>代理模式主要缺点：<br>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；<br>增加了系统的复杂度；</p>
<h3 id="07、适配器（Adapter）模式"><a href="#07、适配器（Adapter）模式" class="headerlink" title="07、适配器（Adapter）模式"></a>07、适配器（Adapter）模式</h3><p>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。<br>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>在现实生活中，经常出现两个对象因接口不兼容而不能在一起工作的实例，这时需要第三者进行适配。<br>例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器，用计算机访问照相机的 SD 内存卡时需要一个读卡器等。</p>
<p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重新开发这些组件成本又很高，这时用适配器模式能很好地解决这些问题。</p>
<p>适配器模式主要优点：<br>客户端通过适配器可以透明地调用目标接口。<br>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。<br>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</p>
<p>适配器主要缺点：<br>对类适配器来说，更换适配器的实现过程比较复杂。</p>
<h3 id="08、桥接（Bridge）模式"><a href="#08、桥接（Bridge）模式" class="headerlink" title="08、桥接（Bridge）模式"></a>08、桥接（Bridge）模式</h3><p>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>在现实生活中，某些类具有两个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似于 Photoshop 这样的软件，能画不同形状和不同颜色的图形呢？<br>如果用继承方式，m 种形状和 n 种颜色的图形就有 m×n 种，不但对应的子类很多，而且扩展困难。<br>当然，这样的例子还有很多，如不同颜色和字体的文字、不同品牌和功率的汽车、不同性别和职业的男女、支持不同平台和不同文件格式的媒体播放器等。如果用桥接模式就能很好地解决这些问题。</p>
<p>桥接模式主要优点：<br>由于抽象与实现分离，所以扩展能力强；<br>其实现细节对客户透明。</p>
<p>桥接模式主要缺点是：<br>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。</p>
<h3 id="09、装饰（Decorator）模式"><a href="#09、装饰（Decorator）模式" class="headerlink" title="09、装饰（Decorator）模式"></a>09、装饰（Decorator）模式</h3><p>装饰（Decorator）模式：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。</p>
<p>在现实生活中，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等。在软件开发过程中，有时想用一些现存的组件。<br>这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以釆用装饰模式来实现。</p>
<p>装饰模式主要优点：<br>采用装饰模式扩展对象的功能比采用继承方式更加灵活。<br>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</p>
<p>装饰模式主要缺点：<br>装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。</p>
<h3 id="10、外观（Facade）模式"><a href="#10、外观（Facade）模式" class="headerlink" title="10、外观（Facade）模式"></a>10、外观（Facade）模式</h3><p>外观（Facade）模式：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节。<br>在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。</p>
<p>软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，<br>所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。外观模式是“迪米特法则”的典型应用。</p>
<p>外观模式主要优点：<br>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。<br>大大降低应用程序的复杂度，提高了程序的可维护性<br>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。<br>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</p>
<p>外观模式主要缺点：<br>不能很好地限制客户使用子系统类。<br>增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>
<h3 id="11、享元（Flyweight）模式"><a href="#11、享元（Flyweight）模式" class="headerlink" title="11、享元（Flyweight）模式"></a>11、享元（Flyweight）模式</h3><p>享元（Flyweight）模式：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。<br>例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。<br>这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。</p>
<p>享元模式主要优点：<br>相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p>
<p>享元模式主要缺点：<br>为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。<br>读取享元模式的外部状态会使得运行时间稍微变长。</p>
<h3 id="12、组合（Composite）模式"><a href="#12、组合（Composite）模式" class="headerlink" title="12、组合（Composite）模式"></a>12、组合（Composite）模式</h3><p>组合（Composite）模式：有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>在现实生活中，存在很多“部分-整体”的关系，例如，大学中的部门与学院、总公司中的部门与分公司、学习用品中的书与书包、生活用品中的衣月艮与衣柜以及厨房中的锅碗瓢盆等。在软件开发中也是这样，<br>例如，文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。</p>
<p>组合模式主要优点：<br>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；<br>更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；</p>
<p>组合模式主要缺点：<br>设计较复杂，客户端需要花更多时间理清类之间的层次关系；<br>不容易限制容器中的构件；<br>不容易用继承的方法来增加构件的新功能；</p>
<h2 id="行为型模式-1"><a href="#行为型模式-1" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。<br>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。<br>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。<br>13、模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。<br>14、策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。<br>15、命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。<br>16、职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。<br>17、状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。<br>18、观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。<br>19、中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。<br>20、迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。<br>21、访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。<br>22、备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。<br>23、解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器</p>
<h3 id="13、模板方法（Template-Method）模式"><a href="#13、模板方法（Template-Method）模式" class="headerlink" title="13、模板方法（Template Method）模式"></a>13、模板方法（Template Method）模式</h3><p>模板方法（Template Method）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。</p>
<p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>
<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>
<p>这样的例子在生活中还有很多，例如，一个人每天会起床、吃饭、做事、睡觉等，其中“做事”的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等。</p>
<p>模板方法模式主要优点：<br>它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。<br>它在父类中提取了公共的部分代码，便于代码复用。<br>部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。</p>
<p>模板方法模式主要缺点：<br>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。<br>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</p>
<h3 id="14、策略（Strategy）模式"><a href="#14、策略（Strategy）模式" class="headerlink" title="14、策略（Strategy）模式"></a>14、策略（Strategy）模式</h3><p>策略（Strategy）模式：该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<p>在现实生活中常常遇到实现某种目标存在多种策略可供选择的情况，例如，出行旅游可以乘坐飞机、乘坐火车、骑自行车或自己开私家车等，超市促销可以釆用打折、送商品、送积分等方法。</p>
<p>在软件开发中也常常遇到类似的情况，当实现某一个功能存在多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能，如数据排序策略有冒泡排序、选择排序、插入排序、二叉树排序等。</p>
<p>如果使用多重条件转移语句实现（即硬编码），不但使条件语句变得很复杂，而且增加、删除或更换算法要修改原代码，不易维护，违背开闭原则。如果采用策略模式就能很好解决该问题。</p>
<p>策略模式主要优点：<br>多重条件语句不易维护，而使用策略模式可以避免使用多重条件语句。<br>策略模式提供了一系列的可供重用的算法族，恰当使用继承可以把算法族的公共代码转移到父类里面，从而避免重复的代码。<br>策略模式可以提供相同行为的不同实现，客户可以根据不同时间或空间要求选择不同的。<br>策略模式提供了对开闭原则的完美支持，可以在不修改原代码的情况下，灵活增加新算法。<br>策略模式把算法的使用放到环境类中，而算法的实现移到具体策略类中，实现了二者的分离。</p>
<p>策略模式主要缺点：<br>客户端必须理解所有策略算法的区别，以便适时选择恰当的算法类。<br>策略模式造成很多的策略类。</p>
<h3 id="15、命令（Command）模式"><a href="#15、命令（Command）模式" class="headerlink" title="15、命令（Command）模式"></a>15、命令（Command）模式</h3><p>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p>
<p>在软件开发系统中，常常出现“方法的请求者”与“方法的实现者”之间存在紧密的耦合关系。这不利于软件功能的扩展与维护。<br>例如，想对行为进行“撤销、重做、记录”等处理都很不方便，因此“如何将方法的请求者与方法的实现者解耦？”变得很重要，命令模式能很好地解决这个问题。</p>
<p>在现实生活中，这样的例子也很多，例如，电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者），还有计算机键盘上的“功能键”等。</p>
<p>命令模式主要优点：<br>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。<br>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。<br>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。<br>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</p>
<p>命令模式主要缺点：<br>可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</p>
<h3 id="16、责任链（Chain-of-Responsibility）模式"><a href="#16、责任链（Chain-of-Responsibility）模式" class="headerlink" title="16、责任链（Chain of Responsibility）模式"></a>16、责任链（Chain of Responsibility）模式</h3><p>责任链（Chain of Responsibility）模式：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p>注意：责任链模式也叫职责链模式。</p>
<p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。</p>
<p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。<br>例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，<br>也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p>
<p>在计算机软硬件中也有相关例子，如总线网中数据报传送，每台计算机根据目标地址是否同自己的地址相同来决定是否接收；还有异常处理中，处理程序根据异常的类型决定自己是否处理该异常；<br>还有 Struts2 的拦截器、JSP 和 Servlet 的 Filter 等，所有这些，如果用责任链模式都能很好解决。</p>
<p>责任链模式主要优点：<br>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。<br>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。<br>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。<br>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。<br>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</p>
<p>责任链模式主要缺点：<br>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。<br>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。<br>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</p>
<h3 id="17、状态（State）模式"><a href="#17、状态（State）模式" class="headerlink" title="17、状态（State）模式"></a>17、状态（State）模式</h3><p>状态（State）模式：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<p>在软件开发过程中，应用程序中的有些对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态。<br>当有状态的对象与外部事件产生互动时，其内部状态会发生改变，从而使得其行为也随之发生改变。如人的情绪有高兴的时候和伤心的时候，不同的情绪有不同的行为，当然外界也会影响其情绪变化。</p>
<p>对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 语句来做状态判断，再进行不同情况的处理。<br>但当对象的状态很多时，程序会变得很复杂。而且增加新的状态要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展。</p>
<p>以上问题如果采用“状态模式”就能很好地得到解决。状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，放到一系列的状态类当中，这样可以把原来复杂的逻辑判断简单化。</p>
<p>状态模式主要优点：<br>状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。<br>减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。<br>有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</p>
<p>状态模式主要缺点：<br>状态模式的使用必然会增加系统的类与对象的个数。<br>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</p>
<h3 id="18、观察者（Observer）模式"><a href="#18、观察者（Observer）模式" class="headerlink" title="18、观察者（Observer）模式"></a>18、观察者（Observer）模式</h3><p>观察者（Observer）模式：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p>
<p>在现实世界中，许多对象并不是独立存在的，其中一个对象的行为发生改变可能会导致一个或者多个其他对象的行为也发生改变。例如，某种商品的物价上涨时会导致部分商家高兴，而消费者伤心；<br>还有，当我们开车到交叉路口时，遇到红灯会停，遇到绿灯会行。这样的例子还有很多，例如，股票价格与股民、微信公众号与微信用户、气象局的天气预报与听众、小偷与警察等。</p>
<p>在软件世界也是这样，例如，Excel中的数据与折线图、饼状图、柱状图之间的关系；MVC模式中的模型与视图的关系；事件模型中的事件源与事件处理者。所有这些，如果用观察者模式来实现就非常方便。</p>
<p>观察者模式主要优点：<br>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。<br>目标与观察者之间建立了一套触发机制。</p>
<p>观察者模式主要缺点：<br>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。<br>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率。</p>
<h3 id="19、中介者（Mediator）模式"><a href="#19、中介者（Mediator）模式" class="headerlink" title="19、中介者（Mediator）模式"></a>19、中介者（Mediator）模式</h3><p>中介者（Mediator）模式：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。中介者模式又叫调停模式，它是迪米特法则的典型应用。</p>
<p>在现实生活中，常常会出现好多对象之间存在复杂的交互关系，这种交互关系常常是“网状结构”，它要求每个对象都必须知道它需要交互的对象。例如，每个人必须记住他（她）所有朋友的电话；<br>而且，朋友中如果有人的电话修改了，他（她）必须告诉其他所有的朋友修改，这叫作“牵一发而动全身”，非常复杂。</p>
<p>如果把这种“网状结构”改为“星形结构”的话，将大大降低它们之间的“耦合性”，这时只要找一个“中介者”就可以了。如前面所说的“每个人必须记住所有朋友电话”的问题，只要在网上建立一个每个朋友都可以访问的“通信录”就解决了。<br>这样的例子还有很多，例如，你刚刚参力口工作想租房，可以找“房屋中介”；或者，自己刚刚到一个陌生城市找工作，可以找“人才交流中心”帮忙。</p>
<p>在软件的开发过程中，这样的例子也很多，例如，在 MVC 框架中，控制器（C）就是模型（M）和视图（V）的中介者；还有大家常用的 QQ 聊天程序的“中介者”是 QQ 服务器。<br>所有这些，都可以采用“中介者模式”来实现，它将大大降低对象之间的耦合性，提高系统的灵活性。</p>
<p>中介者模式实现的关键是找出“中介者”，下面对它的结构和实现进行分析。<br>中介者模式模式的结构<br>中介者模式包含以下主要角色。<br>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。<br>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。<br>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。<br>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p>
<p>中介者模式主要优点：</p>
<p>降低了对象之间的耦合性，使得对象易于独立地被复用。<br>将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。</p>
<p>中介者模式主要缺点：</p>
<p>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<h3 id="20、迭代器（Iterator）模式"><a href="#20、迭代器（Iterator）模式" class="headerlink" title="20、迭代器（Iterator）模式"></a>20、迭代器（Iterator）模式</h3><p>迭代器（Iterator）模式：提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。<br>在现实生活以及程序设计中，经常要访问一个聚合对象中的各个元素，如“数据结构”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。</p>
<p>既然将遍历方法封装在聚合类中不可取，那么聚合类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：<br>暴露了聚合类的内部表示，使其数据不安全；<br>增加了客户的负担。</p>
<p>“迭代器模式”能较好地克服以上缺点，它在客户访问类与聚合类之间插入一个迭代器，这分离了聚合对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”，如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。</p>
<p>迭代器模式主要优点：<br>访问一个聚合对象的内容而无须暴露它的内部表示。<br>遍历任务交由迭代器完成，这简化了聚合类。<br>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。<br>增加新的聚合类和迭代器类都很方便，无须修改原有代码。<br>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</p>
<p>迭代器模式主要缺点：<br>增加了类的个数，这在一定程度上增加了系统的复杂性。</p>
<h3 id="21、访问者（Visitor）模式"><a href="#21、访问者（Visitor）模式" class="headerlink" title="21、访问者（Visitor）模式"></a>21、访问者（Visitor）模式</h3><p>访问者（Visitor）模式：将作用于某种数据结构中的各元素的操作分离出来封装成独立的类，使其在不改变数据结构的前提下可以添加作用于这些元素的新的操作，为数据结构中的每个元素提供多种访问方式。<br>它将对数据的操作与数据结构进行分离，是行为类模式中最复杂的一种模式。</p>
<p>在现实生活中，有些集合对象中存在多种不同的元素，且每种元素也存在多种不同的访问者和处理方式。<br>例如，公园中存在多个景点，也存在多个游客，不同的游客对同一个景点的评价可能不同；医院医生开的处方单中包含多种药元素，査看它的划价员和药房工作人员对它的处理方式也不同，<br>划价员根据处方单上面的药品名和数量进行划价，药房工作人员根据处方单的内容进行抓药。</p>
<p>这样的例子还有很多，例如，电影或电视剧中的人物角色，不同的观众对他们的评价也不同；还有顾客在商场购物时放在“购物车”中的商品，顾客主要关心所选商品的性价比，而收银员关心的是商品的价格和数量。</p>
<p>这些被处理的数据元素相对稳定而访问方式多种多样的数据结构，如果用“访问者模式”来处理比较方便。<br>访问者模式能把处理方法从数据结构中分离出来，并可以根据需要增加新的处理方法，且不用修改原来的程序代码与数据结构，这提高了程序的扩展性和灵活性。</p>
<p>访问者模式主要优点：<br>扩展性好。能够在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。<br>复用性好。可以通过访问者来定义整个对象结构通用的功能，从而提高系统的复用程度。<br>灵活性好。访问者模式将数据结构与作用于结构上的操作解耦，使得操作集合可相对自由地演化而不影响系统的数据结构。<br>符合单一职责原则。访问者模式把相关的行为封装在一起，构成一个访问者，使每一个访问者的功能都比较单一。</p>
<p>访问者模式主要缺点：<br>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。<br>破坏封装。访问者模式中具体元素对访问者公布细节，这破坏了对象的封装性。<br>违反了依赖倒置原则。访问者模式依赖了具体类，而没有依赖抽象类。</p>
<h3 id="22、备忘录（Memento）模式"><a href="#22、备忘录（Memento）模式" class="headerlink" title="22、备忘录（Memento）模式"></a>22、备忘录（Memento）模式</h3><p>备忘录（Memento）模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。该模式又叫快照模式。</p>
<p>每个人都有犯错误的时候，都希望有种“后悔药”能弥补自己的过失，让自己重新开始，但现实是残酷的。在计算机应用中，客户同样会常常犯错误，能否提供“后悔药”给他们呢？当然是可以的，而且是有必要的。这个功能由“备忘录模式”来实现。</p>
<p>其实很多应用软件都提供了这项功能，如使文档恢复到之前的状态、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p>
<p>备忘录模式能记录一个对象的内部状态，当用户后悔时能撤销当前操作，使数据恢复到它原先的状态。</p>
<p>备忘录模式主要优点：<br>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。<br>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。<br>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</p>
<p>备忘录模式主要缺点：<br>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</p>
<h3 id="23、解释器（Interpreter）模式"><a href="#23、解释器（Interpreter）模式" class="headerlink" title="23、解释器（Interpreter）模式"></a>23、解释器（Interpreter）模式</h3><p>解释器（Interpreter）模式：给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。</p>
<p>这里提到的文法和句子的概念同编译原理中的描述相同，“文法”指语言的语法规则，而“句子”是语言集中的元素。例如，汉语中的句子有很多，“我是中国人”是其中的一个句子，可以用一棵语法树来直观地描述语言中的句子。</p>
<p>在软件开发中，会遇到有些问题多次重复出现，而且有一定的相似性和规律性。如果将它们归纳成一种简单的语言，那么这些问题实例将是该语言的一些句子，这样就可以用“编译原理”中的解释器模式来实现了。</p>
<p>虽然使用解释器模式的实例不是很多，但对于满足以上特点，且对运行效率要求不是很高的应用实例，如果用解释器模式来实现，其效果是非常好的，本文将介绍其工作原理与使用方法。</p>
<p>解释器模式主要优点：<br>扩展性好。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。<br>容易实现。在语法树中的每个表达式节点类都是相似的，所以实现其文法较为容易。</p>
<p>解释器模式主要缺点：<br>执行效率较低。解释器模式中通常使用大量的循环和递归调用，当要解释的句子较复杂时，其运行速度很慢，且代码的调试过程也比较麻烦。<br>会引起类膨胀。解释器模式中的每条规则至少需要定义一个类，当包含的文法规则很多时，类的个数将急剧增加，导致系统难以管理与维护。<br>可应用的场景比较少。在软件开发中，需要定义语言文法的应用实例非常少，所以这种模式很少被使用到。</p>
<p>再一次感谢您花费时间阅读此篇文章，祝您在这里记录、阅读、分享愉快！</p>
<p>2019 年 08月 06日    </p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/2019/08/06/浅谈设计模式/">浅谈设计模式</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">文心鱼塘</a></p>
        <p><span>发布时间:</span>2019-08-06, 14:18:45</p>
        <p><span>最后更新:</span>2019-08-06, 15:44:19</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/2019/08/06/浅谈设计模式/" title="浅谈设计模式">https://znw957799185.github.io/2019/08/06/浅谈设计模式/</a>
            <span class="copy-path" data-clipboard-text="原文: https://znw957799185.github.io/2019/08/06/浅谈设计模式/　　作者: 文心鱼塘" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/2019/08/17/SM2加密的项目应用/">
                    SM2加密的项目应用
                </a>
            </div>
        
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#GoF的23种设计模式的功能"><span class="toc-number">1.</span> <span class="toc-text">GoF的23种设计模式的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#根据目的来分"><span class="toc-number">2.</span> <span class="toc-text">根据目的来分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建型模式"><span class="toc-number">2.1.</span> <span class="toc-text">创建型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#结构型模式"><span class="toc-number">2.2.</span> <span class="toc-text">结构型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#行为型模式"><span class="toc-number">2.3.</span> <span class="toc-text">行为型模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#根据作用范围来分"><span class="toc-number">3.</span> <span class="toc-text">根据作用范围来分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类模式"><span class="toc-number">3.1.</span> <span class="toc-text">类模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象模式"><span class="toc-number">3.2.</span> <span class="toc-text">对象模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#以下是按定义描述23种设计模式"><span class="toc-number">4.</span> <span class="toc-text">以下是按定义描述23种设计模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#软件设计遵循原则"><span class="toc-number"></span> <span class="toc-text">软件设计遵循原则</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#开闭原则："><span class="toc-number">1.</span> <span class="toc-text">开闭原则：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#里氏替换原则："><span class="toc-number">2.</span> <span class="toc-text">里氏替换原则：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#依赖倒置原则："><span class="toc-number">3.</span> <span class="toc-text">依赖倒置原则：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#单一职责原则"><span class="toc-number">4.</span> <span class="toc-text">单一职责原则:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口隔离原则"><span class="toc-number">5.</span> <span class="toc-text">接口隔离原则:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#迪米特法则："><span class="toc-number">6.</span> <span class="toc-text">迪米特法则：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#合成复用原则"><span class="toc-number">7.</span> <span class="toc-text">合成复用原则:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建型模式-1"><span class="toc-number">8.</span> <span class="toc-text">创建型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1、单例（Singleton）模式"><span class="toc-number">8.1.</span> <span class="toc-text">1、单例（Singleton）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2、原型（Prototype）模式"><span class="toc-number">8.2.</span> <span class="toc-text">2、原型（Prototype）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3、工厂方法（FactoryMethod"><span class="toc-number">8.3.</span> <span class="toc-text">3、工厂方法（FactoryMethod)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4、抽象工厂（AbstractFactory）"><span class="toc-number">8.4.</span> <span class="toc-text">4、抽象工厂（AbstractFactory）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5、建造者（Builder）模式"><span class="toc-number">8.5.</span> <span class="toc-text">5、建造者（Builder）模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#结构型模式-1"><span class="toc-number">9.</span> <span class="toc-text">结构型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#06、代理（Proxy）模式"><span class="toc-number">9.1.</span> <span class="toc-text">06、代理（Proxy）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#07、适配器（Adapter）模式"><span class="toc-number">9.2.</span> <span class="toc-text">07、适配器（Adapter）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#08、桥接（Bridge）模式"><span class="toc-number">9.3.</span> <span class="toc-text">08、桥接（Bridge）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#09、装饰（Decorator）模式"><span class="toc-number">9.4.</span> <span class="toc-text">09、装饰（Decorator）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10、外观（Facade）模式"><span class="toc-number">9.5.</span> <span class="toc-text">10、外观（Facade）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11、享元（Flyweight）模式"><span class="toc-number">9.6.</span> <span class="toc-text">11、享元（Flyweight）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12、组合（Composite）模式"><span class="toc-number">9.7.</span> <span class="toc-text">12、组合（Composite）模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#行为型模式-1"><span class="toc-number">10.</span> <span class="toc-text">行为型模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13、模板方法（Template-Method）模式"><span class="toc-number">10.1.</span> <span class="toc-text">13、模板方法（Template Method）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14、策略（Strategy）模式"><span class="toc-number">10.2.</span> <span class="toc-text">14、策略（Strategy）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15、命令（Command）模式"><span class="toc-number">10.3.</span> <span class="toc-text">15、命令（Command）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16、责任链（Chain-of-Responsibility）模式"><span class="toc-number">10.4.</span> <span class="toc-text">16、责任链（Chain of Responsibility）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17、状态（State）模式"><span class="toc-number">10.5.</span> <span class="toc-text">17、状态（State）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18、观察者（Observer）模式"><span class="toc-number">10.6.</span> <span class="toc-text">18、观察者（Observer）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19、中介者（Mediator）模式"><span class="toc-number">10.7.</span> <span class="toc-text">19、中介者（Mediator）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20、迭代器（Iterator）模式"><span class="toc-number">10.8.</span> <span class="toc-text">20、迭代器（Iterator）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21、访问者（Visitor）模式"><span class="toc-number">10.9.</span> <span class="toc-text">21、访问者（Visitor）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22、备忘录（Memento）模式"><span class="toc-number">10.10.</span> <span class="toc-text">22、备忘录（Memento）模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23、解释器（Interpreter）模式"><span class="toc-number">10.11.</span> <span class="toc-text">23、解释器（Interpreter）模式</span></a></li></ol></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>



    
<div class="share">
    
        <div class="bdsharebuttonbox">
            <a href="#" class="fa fa-twitter bds_twi" data-cmd="twi" title="分享到推特"></a>
            <a href="#" class="fa fa-weibo bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a>
            <a href="#" class="fa fa-qq bds_sqq" data-cmd="sqq" title="分享给 QQ 好友"></a>
            <a href="#" class="fa fa-files-o bds_copy" data-cmd="copy" title="复制网址"></a>
            <a href="#" class="fa fa fa-envelope-o bds_mail" data-cmd="mail" title="通过邮件分享"></a>
            <a href="#" class="fa fa-weixin bds_weixin" data-cmd="weixin" title="生成文章二维码"></a>
            <a href="#" class="fa fa-share-alt bds_more" data-cmd="more"></i></a>
        </div>
        <script>
            window._bd_share_config={
                "common":{"bdSnsKey":{},"bdText":"浅谈设计模式　| Hexo　","bdMini":"2","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];
        </script>
    

    
</div>







    




    <div class="scroll" id="post-nav-button">
        
            <a href="/2019/08/17/SM2加密的项目应用/" title="上一篇: SM2加密的项目应用">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/" title="回到主页"><i class="fa fa-home"></i></a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/08/17/SM2加密的项目应用/">SM2加密的项目应用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/08/06/浅谈设计模式/">浅谈设计模式</a></li></ul>




    <script>
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2019 文心鱼塘
            </div>
            <div class="footer-right">
                <a href="http://hexo.io/" target="_blank" title="快速、简洁且高效的博客框架">Hexo</a>  Theme <a href="https://github.com/MOxFIVE/hexo-theme-yelee" target="_blank" title="简而不减 Hexo 双栏博客主题  v3.5">Yelee</a> by MOxFIVE <i class="fa fa-heart animated infinite pulse"></i>
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 5;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>





    <script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
            
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>